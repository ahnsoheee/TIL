## 인덱스

- 데이터베이스에서 테이블의 검색 속도 향상을 위한 자료구조

### 인덱스 관리
- INSERT: 새로운 데이터에 대한 인덱스를 추가한다.
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행한다.
- UPDATE: 기존의 인덱스를 사용하지 않음으로 처리하고, 갱신된 데이터에 대한 인덱스를 추가한다.

### 장점
- 검색과 정렬 속도와 성능을 향상시킬 수 있다.
- 그룹화 작업의 속도를 향상된다.
- 테이블 행의 고유성을 강화시킬 수 있다.
- 시스템 부하를 줄일 수 있다.


    #### 인덱스를 사용하면 좋은 경우
    - 규모가 큰 테이블
    - INSERT, DELETE, UPDATE가 자주 발생하지 않는 컬럼
    - 데이터의 중복도가 낮은 컬럼
    - JOIN이나 WHERE, ORDER BY에 자주 사용되는 컬럼
    - MIN, MAX를 자주 사용하는 컬럼

### 단점
- 가장 큰 문제점은 정렬된 상태를 유지 시켜주어야 한다는 점이다.
- 인덱스 관리를 위해 DB의 약 10%에 해당하는 저장 공간이 필요하다.
- 인덱스를 관리하기 위한 추가 작업이 필요하다.
- DML에 취약하다.
- 잘못 사용하는 경우 성능이 저하될 수 있다.
    - CREATE, UPDATE, DELETE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져 성능이 저하되는 역효과가 발생할 수 있다. UPDATE와 DELETE는 기존 인덱스를 사용하지 않음으로 처리하기 때문이다.

### 인덱스 구조
#### Hash 
- 부등호 연산이 자주 사용되는 검색에는 해시 테이블이 적합하지 않다.
- Hash(https://github.com/ahnsoheee/TIL/blob/master/Data%20structure/HashMap_Map.md)

#### B-Tree 

![image](https://user-images.githubusercontent.com/61968474/134815516-03c02fa9-d890-4da8-93de-29fea10c9446.png)

- 트리 구조 인덱스
- 데이터가 정렬된 상태로 유지되어 있다.
- 리프, 브랜치 노드 모두 데이터 저장 가능
- 한 노드 당 자식 노드가 2개 이상 가능
- 트리 구조를 활용하여 key 값을 이용해 데이터를 찾는다.
- B-Tree 균형트리이기 때문에 어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다. (균일성)

**B-Tree 인덱스의 종류**

- Unique Index
    - 인덱스 안에 있는 컬럼 key에 갑셍 중복되는 데이터가 없다.
    ```sql
    create unique index [인덱스명] on [테이블명(key로 지정할 컬럼명1, 컬럼명2 ...)]
    ```
- Non-unique Index
    - 중복되는 데이터가 들어가야 하는 경우
    ```sql
    create index [인덱스명] on [테이블명(컬럼명1, 컬럼명2 ...)]
    ```
- FBI 인덱스 (Function Based Index)
    - 함수 기반 인덱스
    
- Descending Index
    - 내림차순으로 인덱스를 생성한다.
    - 큰 값을 많이 조회하는 SQL에 생성하는 것이 좋다.

- 결합 인덱스 (Composite Index)
    - 인덱스 생성 시 두 개 이상의 컬럼을 합쳐서 인덱스를 생성한다.

#### B+Tree
- B-Tree 개선시킨 자료구조이다.
- 리프 노드만 인덱스와 함께 데이터를 가지고 있고, 나머지 노드들은 데이터를 위한 인덱스(key)만 갖는다.
- 리프 노드들은 LinkedList로 연결되어 있다.
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.
- O(log2n)의 시간복잡도를 갖지만 해시 테이블보다 인덱싱에 적합하다.


#### Bitmap Index
![image](https://user-images.githubusercontent.com/61968474/134816885-30eaeee4-fd98-45d3-b2bf-311622708f09.png)

- 비트를 이용해 컬럼 값을 저장하고, rowid를 자동으로 생성하는 인덱스
- Key값에 중복이 없고, Key값 별로 하나의 비트맵 레코드를 갖는다. 비트맵 상의 각 비트가 하나의 테이블 레코드와 매핑된다.
- B-Tree 인덱스의 문제점으로 인해 탄생했다.
    - 실제 컬럼 값을 인덱스에 보관해야 한다는 점에서 대용량 데이터를 관리할 때 부담이 크다.
    - NOT이나 NULL을 사용하거나 복잡한 OR조건에서는 인덱스의 성능을 보장받지 못한다.

### 인덱스의 종류
#### 키에 따른 인덱스
- Primary Index (기본 인덱스)
    - 기본키를 포함하는 인덱스
    - 키의 순서가 레코드의 순서를 결정 짓는다.

- Secondary Index (보조 인덱스)
    - 기본 인덱스 이외의 인덱스
    - 키의 순서가 레코드의 순서를 의미하지는 않는데

#### 파일 조직에 따른 인덱스
- Clustered Index (집중 인덱스)
    - 데이터 레코드의 물리적 순서가 그 파일에 대한 인덱스 엔트리 순서와 동일하게 유지되도록 구성된 인덱스
    - PRIMARY KEY 설정 시 자동으로 생성되며, 행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬한다.
    - 조회 성능은 빠르나 변경 작업이 일어날 때 키 관련 작업을 추가적으로 해야하기 때문에 성능이 떨어진다.
    - 리프 노드가 필요없고 추가적인 공간이 필요하지 않다.
    
- Non-clustered Index (비집중 인덱스)
    - 테이블당 249개까지 생성이 가능하며, 테이블의 페이지를 정렬하지 않고, 새로운 공간을 할당한다.
    - 클러스터 인덱스보다 많은 공간을 차지한다.

#### 데이터 범위에 따른 인덱스
- Dense Index (밀집 인덱스)
    - 데이터 레코드 각각에 대해 하나의 인덱스 엔트리가 만들어진 인덱스
- Sparse Index (희소 인덱스)
    - 레코드 그룹 또는 데이터 블록에 대해 하나의 엔트리가 만들어진 인덱스


- [참고](https://coding-factory.tistory.com/746)

- [참고](https://brunch.co.kr/@skeks463/25)

- [참고](https://rongscodinghistory.tistory.com/113)