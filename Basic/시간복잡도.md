## 시간복잡도

### 정렬 알고리즘

1. 버블 정렬 : O(N^2)
2. 선택 정렬 : O(N^2)
3. 퀵 정렬 : O(NlogN)
4. 힙 정렬 : O(NlogN)
5. 삽입 정렬 : O(N)
6. 병합 정렬 : O(NlogN)

### 1. Big - O 표기법

- f(n) = 2n^2 - 8n + 3 => O(n^2)
- 단순화된 함수 n^2이 임의의상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 된다. (단, c > 0)

- f(n) = O(g(n))
- 복잡도의 점근적 상한을 의미
- n이 증가함에 따라 O(g(n))이 점근적 상한이라는 것을 보여준다.
- cg(n)이 n0보다 큰 모든 n에 대해서 항상 f(n)보다 크다.


### 2. Big - Ω 표기법

- f(n) = 2n^2 - 8n + 3 => Ω(n^2)
- f(n) = Ω(n^2) 은 'n이 증가함에 따라 2n^2 - 8n + 3이 cn^2보다 작을 수 없다'라는 의미
- f(n) = Ω(g(n))
- 복잡도의 점근적 하한을 의미
- n이 증가함에 따라 Ω(g(n))이 점근적 하한이라는 것을 보여준다.
- cg(n)이 n0보다 큰 모든 n에 대해서 항상 f(n)보다 작다.


### 3. Theta 표기법

- O-표기와 Ω-표기가 같은 경우에 사용
- f(n) = 2n^2 - 8n + 3의 Θ-표기는 Θ(n^2)
- 'f(n)은 n이 증가함에 따라 n^2과 동일한 증가율을 가진다'라는 의미
- f(n) = Θ(g(n))
- n0보다 큰 모든 n에 대해서 Θ-표기가 상한과 하한을 동시에 만족한다는 것을 보여준다.

### O(logN)
#### 이진 탐색
- N개의 정렬된 원소가 들어있는 배열에서 x를 찾을 때 사용
- x와 배열의 중간값을 비교해 'x === 중간값' 이면 반환한다.
- 'x < 중간값'일 때는 배열의 왼쪽부터 재탐색하고, 'x > 중간값'일 경우 오른쪽 부분을 재탐색한다.
- 단계별로 탐색해야 할 원소의 개수가 N/2 -> N/4 -> N/8 ...로 줄어든다.
- N이 16일 때, 16에서 1로 감소하는 순서를 뒤집어서 1에서 16으로 증가하는 순서로 생각해보면 1에 2를 몇 번 곲해야 N이 되는지 계산하면 2^k = N 식이 나오고 k = logN이 된다.

#### 이진 탐색 트리
- 각 단계에서 검색해야 할 노드의 개수가 절반씩 줄어들기 때문에 O(logN)이다.

#### 서로 다른 배열 탐색
```java
for (int i = 0; i < arrayA.length; i++) {
    for (int j = 0; j < arrayB.length; j++) {
        if (arrayA[i] < arrayB[j]) {
            System.out.println(arrayA[i] + "," + arrayB[j]);
        }
    }
}
```
- O(ab) (a: arrayA.length, b:arrayB.length)
- 각 배열의 크기를 고려해야하기 때문에 **O(N^2)이 아니다**.