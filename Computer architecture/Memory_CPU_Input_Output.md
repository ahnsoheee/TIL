## 컴퓨터 구조 3대 요소
- 메모리
- CPU
- 입/출력 장치

### 메모리
![image](https://user-images.githubusercontent.com/61968474/135972358-94816e55-cc49-4a80-bb27-44109f87d914.png)

- 프로세서가 동작하기 위한 미리 작성된 '프로그램' 영역과 값을 읽거나 쓰는 '데이터' 영역으로 나뉜다.
- 롬 - 읽기만 가능한 메모리
- 램 - 읽고 쓸 수 있는 메모리

### CPU (Central Processing Unit)
![image](https://user-images.githubusercontent.com/61968474/135972426-2f28e6ff-7dc3-49f7-9dc7-7aa8a8006d6d.png)

- 메인 메모리에서 읽어온 데이터를 처리하는 장치
- 컴퓨터 시스템을 통제하고 프로그램의 연산을 실행하고 처리하는 제어 장치
- 컴퓨터의 핵심 부품
- 메모리에 저장된 프로그램을 차례대로 fetch해서 해당 명령어를 분류 (decode)해서 실행(execute)한다.
- 여러 종류의 **레지스터**와 연산을 담당하는 **ARU**(산술 논리 연산 장치), 명령을 처리하는 **파이프라인**으로 구성
- fetch : 프로그램의 메모리에서 명령어를 불러오는 역할
- decode : fetch 단계에서 가져온 명령어를 해독해 데이터 정보와 연산 정보를 추출한 뒤 각 장치에 적절한 제어신호를 보내 연산, 처리에 대한 준비를 하는 단계
- execute : 명령어에서 추출한 두 데이터와 연산 정보를 이용해 실제 연산을 하는 단계, 결과가 바로 다음 명령어에 사용될지, 그렇지 않다면 메모리 단계로 갈지, 라이트백 단계로 갈지 결정된다.
- memory : 연산 결과가 다음 명령어에 바로 사용되지 않는다면 메모리에 저장한다.
- write-back : 연산의 마지막 단계, 이전 명령어의 연산 결과가 다음 명령어의 입력 데이터로 사용될 경우, 계산 결과를 레지스터에 다시 쓴다.

#### 명령어 형식
- 명령마다 비트를 쪼개서 다양한 명령을 표현
- 특정메모리 주소에 값을 읽고 쓸 수 있어야한다.
- 레지스터는 프로그램의 변수처럼 값을 저장하거나 읽어서 변경하는 용도로 사용할 수 있다.
- Register 값을 사용할 때와 Value 값 자체를 사용하는 경우를 구분해야 한다.

##

- 명령어 비트코드 예시
    - `LOAD R1, R2, R3` ==> `0001 001 010 000 011` ==> `0x1283`

    - `STORE R5, R3, R4` ==> `0011 101 011 000 100` ==> `0x3AC4`

    - `LOAD R7, R2, #30` ==> `0010 111 010 1 11110` ==> `0x2EBE`

    - `AND R3, R1, R6` ==> `0101 011 001 000 110` ==> `0x5646`

    - `ADD R4, R2, R5` ==> `0111 100 010 000 101` ==> `0x7885`

    - `SUB R4, R6, #8` ==> `1010 100 110 1 01000` ==> `0xA9A8`

    - `MOV R4, #250` ==> `1011 100 011111010` ==> `0xB8FA`
    
    ![image](https://user-images.githubusercontent.com/61968474/135972809-cc9e7fdc-0b57-4f8e-83da-75a26c874eb5.png)

### 입/출력 장치 (Input / Output)
![image](https://user-images.githubusercontent.com/61968474/135972538-983c5732-1c7d-49bd-ad0b-f5f73693ba46.png)

- 입력 장치 : 컴퓨터에 어떤 데이터를 입력하게 해주는 장치
- 출력 장치 : 처리 결과를 표시하는 장치
