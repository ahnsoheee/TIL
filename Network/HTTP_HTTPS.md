## HTTP(Hyper Text T보가 포함된다.
    2. 클라이언트의 메시지를 받은 서버는 ServerHello 메시지를 보내며, ClientHello 메시지의 정보 중 서버에서 사용하기로 한 TLS 버전, 세션 식별자, 암호 설정 등의 정보가 포함된다.
    3. 서버가 클라이언트에 서버의 인증서가 포함된 Certificate 메시지를 보낸다. 이 인증서는 별도의 인증 기관에서 발급받은 것으로, 서버가 신뢰할 수 있는 것임을 인증한다. 전송이 끝나면 ServerHelloDone 메시지를 보내 끝났음을 알린다.
    4. 클라이언트는 서버에서 받은 인증서ransfer Protocol)
- 서버와 클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜이다.
- HTTP는 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로 80번 포트를 사용하고 있다.
- 즉, HTTP 서버는 80번 포트에서 요청을 기다리고 있으며, 클라이언트는 80번 포트로 용청을 보낸다.
- HTTP는 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로채고, 수정될 수 있다.
- HTTP/1, HTTP/2는 TCP 연결을 기반으로 하고 HTTP/3은 UDP 연결을 기반으로 한다.

### HTTP의 구조
- 요청(Request)와 응답(Response)로 구성되며 요청에는 Method, Path, Version, Headers, Body 등으로 구성된다.
```
GET /index.htm HTTP/1.1  -  헤더
Host: google.com  -  호스트
- 공백 -
```

### HTTP의 특성
#### Connectless(비연결성)
- 클라이언트와 서버가 연결된 후 요청에 대한 응답이 끝나면 연결이 끊어지는 성질
- 매번 연결해야 하기 때문에 연결/해제에 대한 오버해드가 발생한다.
- 서버에서 다수의 클라이언트와 계속 연결하고 있다면 많은 리소스가 발생하기 때문에 리소스를 줄이면 더 많은 연결을 할 수 있어 비연결적인 특징을 갖는다.

#### Stateless(무상태)
- 서버는 클라이언트의 상태를 알 수 없다.
- 쿠키와 세션을 활용해 상태를 기억할 수 있다.

## HTTPS
- HTTPS는 이를 보완한 것으로 중간에 암호화 계층을 거쳐 패킷을 암호화 한다.
- TLS를 사용해 암호화된 연결을 한다. 
    - TLS(Transport Layer Security): 암호화를 위한 통신 규약으로 다양한 종류의 보안 통신을 위한 프로토콜이다.
-> TLS와 HTTP가 조합된 프로토콜

    
- HTTPS는 제 3자 인증, 공개키와 비밀키 암호화를 사용한다.
- 제 3자 인증은 인증기관에 등록된 인증서만 신뢰한다.
- 공개키 암호화는 비밀키를 공유하기 위해 사용하고 비밀키 암호화는 통신하는 데이터를 암호화하는데 사용한다.
- 클라이언트는 서버의 신원을 확인하고 통신 암호화에 사용할 세션 키를 공유하기 위해 Handshake 과정을 거친다.
    1. 클라이언트에서 서버에 ClientHello 메시지를 보내며, 클라이언트에서 가능한 TLS 버전, 서버 도메인, 세션 식별자, 암호 설정 등의 정를 검증한다. 인증서의 유효기간, 해당 서버에게 발급된 인증서인지 확인하고 신뢰할 수 있다고 판단하면 다음 단계로 넘어간다.
    5. 클라이언트는 임의의 pre-master secret을 생성한 뒤, 서버가 보낸 인증서에 포함된 공개키를 사용해 암호화하고, ClientKeyExchange 메시지에 포함시켜 서버에 전송한다.
    6. 서버는 전송받은 정보를 복호화해 pre-master secret을 알아내고, 이를 사용해 master secret을 생성한다. 그 뒤 master secret에서 세션 키를 생성해 서버와 클라이언트 간의 통신을 암호화하는데 생성한다. 클라이언트도 pre-master secret을 알기 때문에 같은 과정을 거쳐 세션 키를 스스로 만들 수 있다.
    7. 서버와 클라이언트는 각자 동일한 세션 키를 가지며, 이 키를 사용해 대칭키 암호를 사용하는 통신을 할 수 있다. 우선 서로에게 ChangeCipherSpec 메시지를 보내 앞으로의 모든 통신 내용은 세션 키를 사용해 암호화해 보낼 것을 알려준 뒤 Finished 메시지를 보내 각자의 Handshaking 과정이 끝났음을 알린다.
    8. 이러한 과정으로 서버와 클라이언트 간의 보안 통신이 구성된다.
- 서버에서 클라이언트의 인증서를 요구할 수 있다.
