## Reactor 패턴

### 기본 개념
#### 1. I/O는 속도가 느리다.
- 컴퓨터의 기본 동작 중 가장 느리다.
- RAM에 액세스하는데 나노초(GB/s), 디스크/네트워크의 데이터에 액세스하는데 밀리초(MB/s ~ GB/s)가 걸린다.
- CPU 측면에서 비용은 적게드나, 요청을 보낸 순간부터 작업 완료까지 지연을 동반한다.


#### 2. 블로킹 I/O (전통적 방식)
- I/O 요청에 해당하는 함수 호출은 작업이 완료될 때까지 스레드 실행이 차단된다.
-> 웹 서버가 동일한 스레드에서 여러 연결을 처리할 수 없다. (각 소켓의 모든 I/O작업이 다른 연결을 차단)
- 처리해야하는 동시 연결에 대해 새로운 스레드 / 프로세스를 시작하거나 풀에서 가져온 스레드를 재사용(분리된 스레드에서 처리되기 때문에 다른 요청의 가용성에 영향 x)해야한다.

#### 3. 논 블로킹 I/O
- 데이터가 읽히거나 쓰여질 때까지 기다리지 않고 즉시 반환한다. 그 순간 데이터가 없는 경우 그 순간 반환할 수 있는 데이터가 없음을 나타낸다.
- 액세스 방법: busy-waiting
    - 실제 데이터가 반환될 때까지 루프 내에서 리소스를 폴링하는 방식
    - 비효율적;  대부분의 폴링 알고리즘은 엄청난 양의 CPU 시간 낭비를 초래한다.

#### 4. 이벤트 디멀티플렉싱
- busy-waiting 기술을 사용하지 않고 단일 스레드 내에서 I/O 작업 처리가 가능한 방법
- 이 메커니즘을 동기 이벤트 디멀티플렉서 / 이벤트 통지 인터페이스 라고 한다.
- 리소스로부터 들어오는 I/O 이벤트를 수집해 큐에 넣고, 처리할 수 있는 새 이벤트가 있을 때까지 차단한다. -> 동기식
- 이벤트 디멀티플렉서에 의해 반환된 이벤트가 처리된다.
- 이벤트와 관련된 리소스는 읽기 작업 준비를 마치고 차단되지 않는 상황임이 보증된다.
- 모든 이벤트가 처리되고 나면 다시 디멀티플렉서에서 처리 가능한 이벤트가 발생할 때까지 차단한다. 
- 이벤트 루프
```js
    foreach(event in events) {
        data = event.resource.read();
        if (data === RESOUVE_CLOSED)
            // 리소스가 닫혔으면, 리소스 목록에서 제거
            demultiplexer.unwatch(event.resource);
        else
            // 실제 데이터 처리
            consumeData(data);
    }
```

### Reactor 패턴
- 동시성을 다루는 디자인 패턴 중 하나로, 동시에 들어오는 여러 클라이언트의 요청들을 처리하는 기법
- 각 I/O 작업과 관련된 핸들러를 갖는다. (Node.js - 콜백 함수)
- Node.js 비동기 특성의 핵심

![Node js-3](https://user-images.githubusercontent.com/61968474/147949096-32bfbf38-1233-469c-b8b8-9971c2779e6e.jpg)

<details>
<summary>참고</summary>

- Node.js 디자인패턴


</details>